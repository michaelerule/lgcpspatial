<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>lgcpspatial.posterior &mdash; Fast Log-Gaussian Point-Process Methods for Grid Cells 5 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script integrity="sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK" src="../../_static/jquery.js"></script>
        <script integrity="sha384-lSZeSIVKp9myfKbDQ3GkN/KHjUc+mzg17VKDN4Y2kUeBSJioB9QSM639vM9fuY//" src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Fast Log-Gaussian Point-Process Methods for Grid Cells
              <img src="../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                5
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Tutorial notebooks:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../example%200%20hyperparameter%20groundtruth%20test.html">Example 0: Ground truth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example%201%20load%20data.html">Example 1: Load data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example%202%20heuristic%20parameter%20lgcp%20infer.html">Example 2: Heuristic hyperparameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example%203%20optimize%20hyperparameters.html">Example 3: Optimized hyperparameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example%204%20confidence%20intervals.html">Example 4: Confidence intervals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example%205%20heading%20dependence.html">Example 5: Heading dependence</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Modules in the lgcpspatial package:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../lgcpspatial.lgcp2d.html">lgcp2d</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lgcpspatial.simulate_data.html">simulate_data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lgcpspatial.load_data.html">load_data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lgcpspatial.hyperparameters.html">hyperparameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lgcpspatial.posterior.html">posterior</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lgcpspatial.heading.html">heading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lgcpspatial.estimators.html">estimators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lgcpspatial.util.html">util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lgcpspatial.plot.html">plot</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Fast Log-Gaussian Point-Process Methods for Grid Cells</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">lgcpspatial.posterior</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for lgcpspatial.posterior</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python</span>
<span class="c1"># -*- coding: UTF-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">posterior.py: Subroutines for further analysis of the posterior rate map returned from Gaussian process inference. </span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Load a Matlab-like namespace</span>
<span class="kn">from</span> <span class="nn">numpy</span>         <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">ConvexHull</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span>  <span class="kn">import</span> <span class="n">norm</span><span class="p">,</span><span class="n">LinAlgError</span>

<span class="kn">from</span> <span class="nn">lgcpspatial.loaddata</span> <span class="kn">import</span> <span class="n">bin_spikes</span><span class="p">,</span> <span class="n">Arena</span>
<span class="kn">from</span> <span class="nn">lgcpspatial.lgcp2d</span>   <span class="kn">import</span> <span class="n">chinv</span><span class="p">,</span><span class="n">chsolve</span><span class="p">,</span><span class="n">RI</span>
<span class="kn">from</span> <span class="nn">lgcpspatial.plot</span>     <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">lgcpspatial.util</span>     <span class="kn">import</span> <span class="o">*</span>

<div class="viewcode-block" id="findpeaks"><a class="viewcode-back" href="../../lgcpspatial.posterior.html#lgcpspatial.posterior.findpeaks">[docs]</a><span class="k">def</span> <span class="nf">findpeaks</span><span class="p">(</span>
    <span class="n">q</span><span class="p">,</span>
    <span class="n">height_threshold</span> <span class="o">=</span> <span class="o">-</span><span class="n">inf</span><span class="p">,</span>
    <span class="n">clearance_radius</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find points higher than height_threshold, that are also </span>
<span class="sd">    higher than all other points in a radius r circular</span>
<span class="sd">    neighborhood.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q: np.float32</span>
<span class="sd">        2D array of potential values</span>
<span class="sd">        </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    height_threshold: float</span>
<span class="sd">        Peaks must be higher than this to cound.</span>
<span class="sd">    clearance_radius: int</span>
<span class="sd">        Peaks must be larger than all other pixels in radius</span>
<span class="sd">        ``clearance_radius`` to count.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :np.bool</span>
<span class="sd">        2D boolean array of the same sape as q, indicating</span>
<span class="sd">        which pixels are local maxima within radius ``r``.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">L</span>  <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">clearance_radius</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="n">clearance_radius</span><span class="p">)</span>
    
    <span class="c1"># Add padding</span>
    <span class="n">rpad</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">clearance_radius</span><span class="p">)))</span>
    <span class="n">Lpad</span> <span class="o">=</span> <span class="n">L</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">rpad</span><span class="p">;</span>
    <span class="n">qpad</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">Lpad</span><span class="p">,</span><span class="n">Lpad</span><span class="p">)</span><span class="o">+</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span><span class="n">dtype</span><span class="o">=</span><span class="n">q</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">qpad</span><span class="p">[</span><span class="n">rpad</span><span class="p">:</span><span class="o">-</span><span class="n">rpad</span><span class="p">,</span><span class="n">rpad</span><span class="p">:</span><span class="o">-</span><span class="n">rpad</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[:,:,</span><span class="o">...</span><span class="p">]</span>

    <span class="c1"># Points to search</span>
    <span class="n">Δ</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">rpad</span><span class="p">,</span><span class="n">rpad</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">limit</span> <span class="o">=</span> <span class="n">clearance_radius</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">search</span> <span class="o">=</span> <span class="p">{(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> 
              <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Δ</span> 
              <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Δ</span> 
              <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">*</span><span class="n">j</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">limit</span><span class="p">}</span>
    
    <span class="c1"># Only points above the threshold are candidate peaks</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="o">&gt;</span><span class="n">height_threshold</span>
    
    <span class="c1"># Mask away points that have a taller neighbor</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">search</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">&amp;=</span> <span class="n">q</span><span class="o">&gt;</span><span class="n">qpad</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">rpad</span><span class="p">:</span><span class="n">L</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="n">rpad</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="n">rpad</span><span class="p">:</span><span class="n">L</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="n">rpad</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">p</span></div>


<div class="viewcode-block" id="dx_op"><a class="viewcode-back" href="../../lgcpspatial.posterior.html#lgcpspatial.posterior.dx_op">[docs]</a><span class="k">def</span> <span class="nf">dx_op</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Parameters</span>
<span class="sd">    --------------------------------------------------------</span>
<span class="sd">    L: int</span>
<span class="sd">        Size of L×L spatial grid</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># 2D difference operator in the 1st coordinate</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">L</span><span class="p">,</span><span class="n">L</span><span class="p">))</span>
    <span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">=-</span><span class="mf">.5</span>
    <span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="mf">.5</span>
    <span class="k">return</span> <span class="n">dx</span></div>


<div class="viewcode-block" id="hessian_2D"><a class="viewcode-back" href="../../lgcpspatial.posterior.html#lgcpspatial.posterior.hessian_2D">[docs]</a><span class="k">def</span> <span class="nf">hessian_2D</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Get Hessian of discrete 2D function at all points</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    --------------------------------------------------------</span>
<span class="sd">    q: np.complex64</span>
<span class="sd">        List of peak locations encoded as x+iy complex</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">dx</span>  <span class="o">=</span> <span class="n">dx_op</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">f1</span>  <span class="o">=</span> <span class="n">fft2</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>
    <span class="n">f2</span>  <span class="o">=</span> <span class="n">fft2</span><span class="p">(</span><span class="n">dx</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">d11</span> <span class="o">=</span> <span class="n">conv</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">f1</span><span class="o">*</span><span class="n">f1</span><span class="p">)</span>
    <span class="n">d12</span> <span class="o">=</span> <span class="n">conv</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">f2</span><span class="o">*</span><span class="n">f1</span><span class="p">)</span>
    <span class="n">d22</span> <span class="o">=</span> <span class="n">conv</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">f2</span><span class="o">*</span><span class="n">f2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">([[</span><span class="n">d11</span><span class="p">,</span><span class="n">d12</span><span class="p">],[</span><span class="n">d12</span><span class="p">,</span><span class="n">d22</span><span class="p">]])</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="circle_mask"><a class="viewcode-back" href="../../lgcpspatial.posterior.html#lgcpspatial.posterior.circle_mask">[docs]</a><span class="k">def</span> <span class="nf">circle_mask</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span><span class="n">nc</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Zeros out corner frequencies</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    --------------------------------------------------------</span>
<span class="sd">    nr: int</span>
<span class="sd">        number of rows in mask</span>
<span class="sd">    nc: int</span>
<span class="sd">        number of columns in mask</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">arange</span><span class="p">(</span><span class="n">nr</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">nr</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">nr</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">arange</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">nc</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">nc</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">r</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">+</span><span class="n">c</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">.5</span></div>


<div class="viewcode-block" id="fft_upsample_2D"><a class="viewcode-back" href="../../lgcpspatial.posterior.html#lgcpspatial.posterior.fft_upsample_2D">[docs]</a><span class="k">def</span> <span class="nf">fft_upsample_2D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">factor</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Upsample 2D array using the FFT</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    --------------------------------------------------------</span>
<span class="sd">    x: 2D np.float32</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span><span class="o">+</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">nl</span><span class="p">,</span><span class="n">nr</span><span class="p">,</span><span class="n">nc</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">fftshift</span><span class="p">(</span><span class="n">fft2</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">circle_mask</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span><span class="n">nc</span><span class="p">)</span>
    <span class="n">nr2</span><span class="p">,</span><span class="n">nc2</span> <span class="o">=</span> <span class="n">nr</span><span class="o">*</span><span class="n">factor</span><span class="p">,</span><span class="n">nc</span><span class="o">*</span><span class="n">factor</span>
    <span class="n">f2</span> <span class="o">=</span> <span class="n">complex128</span><span class="p">(</span><span class="n">zeros</span><span class="p">((</span><span class="n">nl</span><span class="p">,</span><span class="n">nr2</span><span class="p">,</span><span class="n">nc2</span><span class="p">)))</span>
    <span class="n">r0</span> <span class="o">=</span> <span class="p">(</span><span class="n">nr2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">nr</span><span class="o">+</span><span class="mi">0</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
    <span class="n">c0</span> <span class="o">=</span> <span class="p">(</span><span class="n">nc2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">nc</span><span class="o">+</span><span class="mi">0</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
    <span class="n">f2</span><span class="p">[:,</span><span class="n">r0</span><span class="p">:</span><span class="n">r0</span><span class="o">+</span><span class="n">nr</span><span class="p">,</span><span class="n">c0</span><span class="p">:</span><span class="n">c0</span><span class="o">+</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">real</span><span class="p">(</span><span class="n">ifft2</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span><span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">))))</span>
    <span class="k">return</span> <span class="n">squeeze</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="o">*</span><span class="n">factor</span><span class="o">**</span><span class="mi">2</span></div>


<div class="viewcode-block" id="interpolate_peaks"><a class="viewcode-back" href="../../lgcpspatial.posterior.html#lgcpspatial.posterior.interpolate_peaks">[docs]</a><span class="k">def</span> <span class="nf">interpolate_peaks</span><span class="p">(</span>
    <span class="n">z</span><span class="p">,</span>
    <span class="n">clearance_radius</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">height_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_heights</span>   <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Obtain peak locations by quadratic interpolation</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z: ndarray, L×L×NSAMPLES</span>
<span class="sd">        A 3D array of sampled 2D grid-fields,</span>
<span class="sd">        where the LAST axis is the sample numer. </span>
<span class="sd">        </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    clearance_radius: integer</span>
<span class="sd">        Radius over which point must be local maximum to </span>
<span class="sd">        include. </span>
<span class="sd">        Defaults to 1 (nearest neighbors).</span>
<span class="sd">    height_threshold: float</span>
<span class="sd">        Threshold (in height) for peak inclusion. </span>
<span class="sd">        Defaults to the 25th percentil of z</span>
<span class="sd">    return_heights: boolean; default False</span>
<span class="sd">        Whether to return heights as a second return</span>
<span class="sd">        valude</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    peaks: tuple</span>
<span class="sd">        either ``(ix,iy)`` coordinates of peaks if</span>
<span class="sd">        ``q`` is a 2D array, or ``(ix,iy,iz)`` coordinates</span>
<span class="sd">        if ``q`` is a 3D array. The ``iz`` coordinate</span>
<span class="sd">        will label the sample of ``q`` each peak belongs to.</span>
<span class="sd">    heights: list</span>
<span class="sd">        **Returned only if ``return_heights=True``**; </span>
<span class="sd">        The height of each peak</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">is3d</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">is3d</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="c1"># Peaks are defined as local maxima that are larger than</span>
    <span class="c1"># all other points within radius ``r``, and also higher</span>
    <span class="c1"># than the bottom 25% of log-rate values. </span>
    <span class="k">if</span> <span class="n">height_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">height_threshold</span><span class="o">=</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="mi">25</span><span class="p">)</span>

    <span class="c1"># Local indecies of local maxima    </span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="n">findpeaks</span><span class="p">(</span>
        <span class="n">z</span><span class="p">,</span><span class="n">height_threshold</span><span class="p">,</span><span class="n">clearance_radius</span><span class="p">)</span>
    <span class="n">rx</span><span class="p">,</span><span class="n">ry</span><span class="p">,</span><span class="n">rz</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
    
    <span class="c1"># Get heights at peaks</span>
    <span class="n">heights</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">peaks</span><span class="p">]</span>
    
    <span class="c1"># Use quadratic interpolation to localize peaks</span>
    <span class="n">clip</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rx0</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">rx</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rx2</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">rx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ry0</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">ry</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ry2</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">ry</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">s00</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">rx0</span><span class="p">,</span><span class="n">ry0</span><span class="p">,</span><span class="n">rz</span><span class="p">]</span>
    <span class="n">s01</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">rx0</span><span class="p">,</span><span class="n">ry</span> <span class="p">,</span><span class="n">rz</span><span class="p">]</span>
    <span class="n">s02</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">rx0</span><span class="p">,</span><span class="n">ry2</span><span class="p">,</span><span class="n">rz</span><span class="p">]</span>
    <span class="n">s10</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">rx</span> <span class="p">,</span><span class="n">ry0</span><span class="p">,</span><span class="n">rz</span><span class="p">]</span>
    <span class="n">s11</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">rx</span> <span class="p">,</span><span class="n">ry</span> <span class="p">,</span><span class="n">rz</span><span class="p">]</span>
    <span class="n">s12</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">rx</span> <span class="p">,</span><span class="n">ry2</span><span class="p">,</span><span class="n">rz</span><span class="p">]</span>
    <span class="n">s20</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">rx2</span><span class="p">,</span><span class="n">ry0</span><span class="p">,</span><span class="n">rz</span><span class="p">]</span>
    <span class="n">s21</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">rx2</span><span class="p">,</span><span class="n">ry</span> <span class="p">,</span><span class="n">rz</span><span class="p">]</span>
    <span class="n">s22</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">rx2</span><span class="p">,</span><span class="n">ry2</span><span class="p">,</span><span class="n">rz</span><span class="p">]</span>
    <span class="n">dx</span>  <span class="o">=</span> <span class="p">(</span><span class="n">s21</span> <span class="o">-</span> <span class="n">s01</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">dy</span>  <span class="o">=</span> <span class="p">(</span><span class="n">s12</span> <span class="o">-</span> <span class="n">s10</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">dxx</span> <span class="o">=</span> <span class="n">s21</span><span class="o">+</span><span class="n">s01</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">s11</span>
    <span class="n">dyy</span> <span class="o">=</span> <span class="n">s12</span><span class="o">+</span><span class="n">s10</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">s11</span>
    <span class="n">dxy</span> <span class="o">=</span> <span class="p">(</span><span class="n">s22</span><span class="o">+</span><span class="n">s00</span><span class="o">-</span><span class="n">s20</span><span class="o">-</span><span class="n">s02</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span>
    <span class="n">det</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">dxx</span><span class="o">*</span><span class="n">dyy</span><span class="o">-</span><span class="n">dxy</span><span class="o">*</span><span class="n">dxy</span><span class="p">)</span>
    <span class="n">ix</span>  <span class="o">=</span> <span class="p">(</span><span class="n">rx</span><span class="o">-</span><span class="p">(</span> <span class="n">dx</span><span class="o">*</span><span class="n">dyy</span><span class="o">-</span><span class="n">dy</span><span class="o">*</span><span class="n">dxy</span><span class="p">)</span><span class="o">*</span><span class="n">det</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">/</span><span class="n">L</span>
    <span class="n">iy</span>  <span class="o">=</span> <span class="p">(</span><span class="n">ry</span><span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="n">dx</span><span class="o">*</span><span class="n">dxy</span><span class="o">+</span><span class="n">dy</span><span class="o">*</span><span class="n">dxx</span><span class="p">)</span><span class="o">*</span><span class="n">det</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">/</span><span class="n">L</span>
    <span class="c1"># Rarely, ill-conditioning leads to inappropriate </span>
    <span class="c1"># interpolation. We remove these cases. </span>
    <span class="n">bad</span> <span class="o">=</span> <span class="p">(</span><span class="n">ix</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ix</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">L</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">iy</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">iy</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">L</span><span class="p">)</span>
    <span class="n">ix</span>  <span class="o">=</span> <span class="n">ix</span><span class="p">[</span><span class="o">~</span><span class="n">bad</span><span class="p">]</span>
    <span class="n">iy</span>  <span class="o">=</span> <span class="n">iy</span><span class="p">[</span><span class="o">~</span><span class="n">bad</span><span class="p">]</span>
    
    <span class="n">peaks</span> <span class="o">=</span> <span class="n">float32</span><span class="p">((</span><span class="n">iy</span><span class="p">,</span><span class="n">ix</span><span class="p">,</span><span class="n">rz</span><span class="p">[</span><span class="o">~</span><span class="n">bad</span><span class="p">])</span> <span class="k">if</span> <span class="n">is3d</span> <span class="k">else</span> <span class="p">(</span><span class="n">iy</span><span class="p">,</span><span class="n">ix</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">return_heights</span><span class="p">:</span>
        <span class="n">heights</span> <span class="o">=</span> <span class="n">heights</span><span class="p">[</span><span class="o">~</span><span class="n">bad</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">peaks</span><span class="p">,</span> <span class="n">heights</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">peaks</span></div>


<div class="viewcode-block" id="get_peak_density"><a class="viewcode-back" href="../../lgcpspatial.posterior.html#lgcpspatial.posterior.get_peak_density">[docs]</a><span class="k">def</span> <span class="nf">get_peak_density</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">resolution</span><span class="p">,</span><span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">height_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Obtain peaks by quadratic interpolation, then bin</span>
<span class="sd">    the results to a spatial grid with linear interpolation.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    --------------------------------------------------------</span>
<span class="sd">    z: ndarray, L×L×NSAMPLES</span>
<span class="sd">        A 3D array of 2D grid field samples,</span>
<span class="sd">        where the LAST axis is the sample numer. </span>
<span class="sd">    resolution: int&gt;1</span>
<span class="sd">        Upsampling factor for binned peal locations</span>
<span class="sd">        </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    --------------------------------------------------------</span>
<span class="sd">    r: int (default 1)</span>
<span class="sd">        Radius over which point must be local maximum to include. </span>
<span class="sd">    height_threshold: float</span>
<span class="sd">        Threshold (in height) for peak inclusion. </span>
<span class="sd">        Defaults to the 25th percentile of z</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Get list of peak locations</span>
    <span class="n">iy</span><span class="p">,</span><span class="n">ix</span> <span class="o">=</span> <span class="n">interpolate_peaks</span><span class="p">(</span><span class="n">z</span><span class="p">,</span>
        <span class="n">clearance_radius</span> <span class="o">=</span> <span class="n">r</span><span class="p">,</span>
        <span class="n">height_threshold</span> <span class="o">=</span> <span class="n">height_threshold</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1"># Bin peaks on a (possibly finer) spatial grid with</span>
    <span class="c1"># linear interpolation. </span>
    <span class="k">return</span> <span class="n">bin_spikes</span><span class="p">(</span><span class="n">iy</span><span class="p">,</span><span class="n">ix</span><span class="p">,</span><span class="mi">0</span><span class="o">*</span><span class="n">iy</span><span class="p">,</span><span class="n">L</span><span class="o">*</span><span class="n">resolution</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="sample_posterior_lograte"><a class="viewcode-back" href="../../lgcpspatial.posterior.html#lgcpspatial.posterior.sample_posterior_lograte">[docs]</a><span class="k">def</span> <span class="nf">sample_posterior_lograte</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">posterior_mean</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">nsamples</span><span class="o">=</span><span class="mi">200</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Sample from the Gaussian log-rate posterior. </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    --------------------------------------------------------</span>
<span class="sd">    model: </span>
<span class="sd">        a ``diagonal_fourier_lowrank`` model object </span>
<span class="sd">    posterior_mean: float32</span>
<span class="sd">        low-rank posterior mean returned by </span>
<span class="sd">        ``coordinate_descent(model)``</span>
<span class="sd">    v: float32</span>
<span class="sd">        marginal variances returned by </span>
<span class="sd">        ``coordinate_descent(model)``</span>
<span class="sd">        </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    --------------------------------------------------------</span>
<span class="sd">    nsamples: int&gt;1</span>
<span class="sd">        Number of samples to draw; </span>
<span class="sd">        Default is 200</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    --------------------------------------------------------</span>
<span class="sd">    z: L×L×nsamples float32 array</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># Get saved state from the model then </span>
    <span class="c1"># Retrieve the posterior mean log-rate and mean-rate</span>
    <span class="n">n</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">μ0</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">use2d</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">Λ</span><span class="p">,</span><span class="n">h2e</span><span class="p">,</span><span class="n">M</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">cached</span>
    <span class="n">μ</span><span class="p">,</span><span class="n">λ</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">rates_from_lowrank</span><span class="p">(</span><span class="n">posterior_mean</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>

    <span class="c1"># Get Cholesky factor of low-rank posterior covariance</span>
    <span class="c1"># Σq = inv(Λq) = Cq&#39; Cq and Λq = CΛq CΛq&#39;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">λ</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:]</span><span class="o">*</span><span class="n">h2e</span> <span class="c1"># ⎷ of precisions</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">chinv</span><span class="p">(</span><span class="n">float32</span><span class="p">(</span><span class="n">diag</span><span class="p">(</span><span class="n">Λ</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="nd">@x</span><span class="o">.</span><span class="n">T</span><span class="p">))</span> <span class="c1"># Σ Cholesky</span>
    
    <span class="c1"># Draw samples from Gaussian posterior</span>
    <span class="c1"># Δ: diplacement from low-d mean </span>
    <span class="c1"># zh: low-d samples</span>
    <span class="n">Δ</span>  <span class="o">=</span> <span class="n">C</span><span class="nd">@float32</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">nsamples</span><span class="p">))</span> 
    <span class="n">zh</span> <span class="o">=</span> <span class="n">Δ</span> <span class="o">+</span> <span class="n">posterior_mean</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>      
    
    <span class="c1"># Convert log-rate samples to position space and return</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">h2e</span><span class="o">.</span><span class="n">T</span><span class="nd">@zh</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">nsamples</span><span class="p">)</span></div>


<div class="viewcode-block" id="PosteriorSample"><a class="viewcode-back" href="../../lgcpspatial.posterior.html#lgcpspatial.posterior.PosteriorSample">[docs]</a><span class="k">class</span> <span class="nc">PosteriorSample</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    density:</span>
<span class="sd">        Counts of total number of times a field peak</span>
<span class="sd">        appeared at each location for all samples.</span>
<span class="sd">    pfield:</span>
<span class="sd">        Normalized (sum to 1) density of peak locations</span>
<span class="sd">        for each grid field. Grid fields are defined as </span>
<span class="sd">        a local region around each local maximum in the </span>
<span class="sd">        peak ``density`` map.</span>
<span class="sd">    peaks: np.float32</span>
<span class="sd">        2xNPEAKS array of grid-field-peak (x,y) </span>
<span class="sd">        coordinates.</span>
<span class="sd">    totals:</span>
<span class="sd">        Number of samples within each peak basin that</span>
<span class="sd">        actually contained a peak.</span>
<span class="sd">    means: np.float32</span>
<span class="sd">        Center of mass of each peak</span>
<span class="sd">    sigmas: np.float32</span>
<span class="sd">        2D sampled covariance of each peak</span>
<span class="sd">    nearest: np.float32</span>
<span class="sd">        (L*resolution)x(L*resolution) map of Voronoi </span>
<span class="sd">        regions for each peak</span>
<span class="sd">    kde: np.float32</span>
<span class="sd">        (L*resolution)x(L*resolution) smoothed peak </span>
<span class="sd">        density map.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">model</span><span class="p">,</span>
        <span class="n">posterior_mean</span><span class="p">,</span>
        <span class="n">posterior_variance</span><span class="p">,</span>
        <span class="n">arena</span>            <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nsamples</span>         <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
        <span class="n">resolution</span>       <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">radius</span>           <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">edge_radius</span>      <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">height_threshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">prpeak_threshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sample the distribution of grid-field peaks from </span>
<span class="sd">        a log-Gaussian posterior distribution.</span>

<span class="sd">         1. Draw samples in the low-rank space</span>
<span class="sd">         2. Convert them to spatial coordinates</span>
<span class="sd">         3. Get probable location of each grid field peak</span>
<span class="sd">         </span>
<span class="sd">        (Treat this class simply as a function with named</span>
<span class="sd">        return values)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model: </span>
<span class="sd">            a ``diagonal_fourier_lowrank`` model object </span>
<span class="sd">        posterior_mean: </span>
<span class="sd">            low-rank posterior mean returned by </span>
<span class="sd">            ``coordinate_descent(model)``</span>
<span class="sd">        posterior_variance: </span>
<span class="sd">            marginal variances returned by </span>
<span class="sd">            ``coordinate_descent(model)``</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        Arena: object</span>
<span class="sd">            An object with an atrribute</span>
<span class="sd">            hull: scipy.spatial._qhull.ConvexHull</span>
<span class="sd">                Convex Hull object describing the arena </span>
<span class="sd">                perimeter. Points will be clipped to this if</span>
<span class="sd">                it is not None. Ensure this convex hull has </span>
<span class="sd">                been scaled up by the same factor if </span>
<span class="sd">                ``resolution`` is &gt;1.</span>
<span class="sd">        nsamples: int&gt;1</span>
<span class="sd">            Number of samples to draw; </span>
<span class="sd">            Default is 200</span>
<span class="sd">        resolution: int&gt;0</span>
<span class="sd">            Upsampling factor compared to the bin-grid </span>
<span class="sd">            resolution; Default is 2</span>
<span class="sd">        radius: float</span>
<span class="sd">            Local region (in units of pixels on the L×L</span>
<span class="sd">            grid) that peaks should clear to be included.</span>
<span class="sd">            I suggest P/2.5</span>
<span class="sd">        edge_radius: float; Default 0</span>
<span class="sd">            Remove peaks closer than ``edge_radius`` bins</span>
<span class="sd">            to the arena&#39;s edge. The default value of 0</span>
<span class="sd">            does not remove points within a margin of</span>
<span class="sd">            the boundary.</span>
<span class="sd">        height_threshold: float</span>
<span class="sd">            Peak height threshold</span>
<span class="sd">        prpeak_threshold: float</span>
<span class="sd">            Probability threshold for including a peak,</span>
<span class="sd">            in [0,1], based on the fractions of samples</span>
<span class="sd">            that contain a given peak.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Get log-rate samples</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">sample_posterior_lograte</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span>
            <span class="n">posterior_mean</span><span class="p">,</span>
            <span class="n">posterior_variance</span><span class="p">,</span>
            <span class="n">nsamples</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">L</span>
        
        <span class="c1"># Count peaks at each location with linear interp.</span>
        <span class="n">density</span> <span class="o">=</span> <span class="n">get_peak_density</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">resolution</span><span class="p">,</span>
            <span class="n">height_threshold</span><span class="o">=</span><span class="n">percentile</span><span class="p">(</span>
                <span class="n">z</span><span class="p">,</span><span class="mi">100</span><span class="o">*</span><span class="n">height_threshold</span><span class="p">))</span><span class="o">/</span><span class="n">nsamples</span>
        
        <span class="c1"># Normalize the region around each of the  </span>
        <span class="c1"># identified grid-field centers</span>
        <span class="c1"># Focus on a local radius of r=P/2.5</span>
        <span class="c1"># Gaussian blur (σ=r/8) density to find fields</span>
        <span class="n">pfield</span>  <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">density</span><span class="p">))</span>
        
        <span class="c1"># Get density-peak centroids with interpolation</span>
        <span class="c1"># Peak locations are returned in [0,1] coordinates</span>
        <span class="n">kde</span>   <span class="o">=</span> <span class="n">blur</span><span class="p">(</span><span class="n">density</span><span class="p">,</span><span class="n">radius</span><span class="o">*</span><span class="n">resolution</span><span class="o">/</span><span class="mi">7</span><span class="p">)</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">interpolate_peaks</span><span class="p">(</span>
            <span class="n">kde</span><span class="p">,</span>
            <span class="n">clearance_radius</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">radius</span><span class="o">*</span><span class="n">resolution</span><span class="p">))</span>
        
        <span class="c1"># Remove points outside hull or too close to edge</span>
        <span class="n">keep</span>  <span class="o">=</span> <span class="n">is_in_hull</span><span class="p">(</span><span class="n">peaks</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">arena</span><span class="o">.</span><span class="n">hull</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_radius</span><span class="o">&gt;</span><span class="mf">0.</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">arena</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="n">keep</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">arena</span><span class="o">.</span><span class="n">close_to_boundary</span><span class="p">(</span>
                <span class="n">peaks</span><span class="p">,</span> 
                <span class="n">edge_radius</span><span class="p">)</span>
        
        <span class="c1"># Calculate Voronoi region around each peak.</span>
        <span class="c1"># It is useful to retain out-of-bounds peaks</span>
        <span class="c1"># here since these limit the domain of peaks</span>
        <span class="c1"># close to the edge of the arena.</span>
        <span class="n">rz</span>      <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="n">j</span><span class="p">]</span><span class="nd">@peaks</span>
        <span class="n">lr</span>      <span class="o">=</span> <span class="n">L</span><span class="o">*</span><span class="n">resolution</span>
        <span class="n">grid</span>    <span class="o">=</span> <span class="n">zgrid</span><span class="p">(</span><span class="n">lr</span><span class="p">)</span><span class="o">/</span><span class="n">lr</span><span class="o">+</span><span class="mf">.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span>
        <span class="n">D</span>       <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">grid</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">-</span><span class="n">rz</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:])</span>
        <span class="n">nearest</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="n">argmin</span><span class="p">(</span><span class="n">D</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">nearest</span><span class="p">[</span><span class="n">nanmin</span><span class="p">(</span><span class="n">D</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">&gt;</span><span class="n">model</span><span class="o">.</span><span class="n">P</span><span class="o">/</span><span class="n">L</span><span class="p">]</span><span class="o">=</span><span class="n">NaN</span>

        <span class="n">field_ids</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">nearest</span><span class="p">)</span>
        <span class="n">field_ids</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="n">field_ids</span><span class="p">[</span><span class="n">isfinite</span><span class="p">(</span><span class="n">field_ids</span><span class="p">)])</span>

        <span class="c1"># Iterate over all grid fields</span>
        <span class="c1"># Normalize density within each field</span>
        <span class="n">npeaks</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span>
        <span class="n">totals</span> <span class="o">=</span> <span class="n">full</span><span class="p">(</span><span class="n">npeaks</span><span class="p">,</span><span class="n">NaN</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
        <span class="n">means</span>  <span class="o">=</span> <span class="n">full</span><span class="p">((</span><span class="n">npeaks</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">NaN</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
        <span class="n">sigmas</span> <span class="o">=</span> <span class="n">full</span><span class="p">((</span><span class="n">npeaks</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">NaN</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s1">&#39;No valid peaks were found&#39;</span><span class="p">)</span>
        
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">peaks</span><span class="p">[:,</span><span class="n">keep</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="nb">id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">keep</span><span class="p">)):</span>
            <span class="n">match</span>         <span class="o">=</span> <span class="n">nearest</span><span class="o">==</span><span class="nb">id</span>
            <span class="n">regional</span>      <span class="o">=</span> <span class="n">kde</span><span class="p">[</span><span class="n">match</span><span class="p">]</span>
            <span class="n">totals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>     <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">regional</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">totals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">pr</span>            <span class="o">=</span> <span class="n">regional</span><span class="o">/</span><span class="n">totals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">pfield</span><span class="p">[</span><span class="n">match</span><span class="p">]</span> <span class="o">=</span> <span class="n">pr</span>
            <span class="c1"># Calculate moments</span>
            <span class="n">mu</span>        <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">match</span><span class="p">]</span><span class="o">*</span><span class="n">pr</span><span class="p">)</span>
            <span class="n">delta</span>     <span class="o">=</span> <span class="n">c2p</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">match</span><span class="p">]</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">sigmas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;zN,ZN,N-&gt;zZ&#39;</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">pr</span><span class="p">)</span>
            <span class="n">means</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="o">=</span> <span class="n">c2p</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="n">totals</span><span class="p">)</span>
        <span class="n">keep</span>   <span class="o">=</span> <span class="p">(</span><span class="n">totals</span> <span class="o">&gt;</span> <span class="n">prpeak_threshold</span><span class="o">*</span><span class="n">nsamples</span><span class="p">)</span> <span class="o">&amp;</span> \
            <span class="n">is_in_hull</span><span class="p">(</span><span class="n">means</span><span class="p">,</span><span class="n">arena</span><span class="o">.</span><span class="n">hull</span><span class="p">)</span>
        <span class="n">peaks</span>  <span class="o">=</span> <span class="n">peaks</span><span class="p">[:,</span><span class="n">keep</span><span class="p">]</span>
        <span class="n">totals</span> <span class="o">=</span> <span class="n">totals</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        <span class="n">means</span>  <span class="o">=</span> <span class="n">means</span> <span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        <span class="n">sigmas</span> <span class="o">=</span> <span class="n">sigmas</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">density</span> <span class="o">=</span> <span class="n">density</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pfield</span>  <span class="o">=</span> <span class="n">pfield</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span>   <span class="o">=</span> <span class="n">peaks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">totals</span>  <span class="o">=</span> <span class="n">totals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">means</span>   <span class="o">=</span> <span class="n">means</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigmas</span>  <span class="o">=</span> <span class="n">sigmas</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nearest</span> <span class="o">=</span> <span class="n">nearest</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kde</span>     <span class="o">=</span> <span class="n">kde</span></div>


<div class="viewcode-block" id="SampledConfidence"><a class="viewcode-back" href="../../lgcpspatial.posterior.html#lgcpspatial.posterior.SampledConfidence">[docs]</a><span class="k">class</span> <span class="nc">SampledConfidence</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    samples: PosteriorSample</span>
<span class="sd">        A ``PosteriorSample`` object.</span>
<span class="sd">    ellipses: </span>
<span class="sd">        NaN-delimeted (x,y) coordinates for plotting </span>
<span class="sd">        confidence ellipses; </span>
<span class="sd">    gaussians: List</span>
<span class="sd">        (μ,Σ) 2D confidence Gaussians for all peaks.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">model</span><span class="p">,</span>
        <span class="n">fit</span><span class="p">,</span>
        <span class="n">radius</span>           <span class="o">=</span> <span class="mf">0.45</span><span class="p">,</span>
        <span class="n">edge_radius</span>      <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">resolution</span>       <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">nsamples</span>         <span class="o">=</span> <span class="mi">4000</span><span class="p">,</span>
        <span class="n">height_threshold</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span>
        <span class="n">prpeak_threshold</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span>
        <span class="n">pct</span>              <span class="o">=</span> <span class="mi">95</span><span class="p">,</span>
        <span class="n">doplot</span>           <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cmap</span>             <span class="o">=</span> <span class="s1">&#39;bone_r&#39;</span><span class="p">,</span>
        <span class="n">scalebar</span>         <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">draw_border</span>      <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;        </span>
<span class="sd">        Construct confidence intervals for grid-field peaks</span>
<span class="sd">        using sampling, and (optionally) plot them.</span>
<span class="sd">                </span>
<span class="sd">        **For small posterior variance:** The resulting</span>
<span class="sd">        confidence intervals may be too large, since </span>
<span class="sd">        spurious peaks near the edges of a field&#39;s Voronoi </span>
<span class="sd">        cell are counted toward the posterior peak-location</span>
<span class="sd">        variance. This is conservative.</span>
<span class="sd">                </span>
<span class="sd">        **For large posterior variance:** We estimate the</span>
<span class="sd">        uncertainty in a peak&#39;s location by measuring</span>
<span class="sd">        the variance of each peak in the peak-density map.</span>
<span class="sd">        These samples are limited to each peak&#39;s Voronoi </span>
<span class="sd">        cell, which creates an upper bound on the </span>
<span class="sd">        uncertainty. I.e. this will always report that</span>
<span class="sd">        grid-field peaks are localized to within one </span>
<span class="sd">        grid-cell period. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : </span>
<span class="sd">            Object containing the following attributes:</span>
<span class="sd">        model: diagonal_fourier_lowrank</span>
<span class="sd">            Model built from this data of type </span>
<span class="sd">            lgcp2d.diagonal_fourier_lowrank</span>
<span class="sd">        fit: </span>
<span class="sd">            Fit posterior calculated by </span>
<span class="sd">            lgcp2d.coordinate_descent</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        radius: positive float; default 0.45</span>
<span class="sd">            Region in which peak must be a local maximum to </span>
<span class="sd">            be considered a grid field. </span>
<span class="sd">            This is in units of </span>
<span class="sd">            **fraction of the grid-cell period ``model.P``**.</span>
<span class="sd">        edge_radius: positive float; Default 0.0</span>
<span class="sd">            Remove peaks closer than ``edge_radius`` </span>
<span class="sd">            to the arena&#39;s edge. The default value of 0</span>
<span class="sd">            does not remove points within a margin of</span>
<span class="sd">            the boundary.</span>
<span class="sd">            This is in units of </span>
<span class="sd">            **fraction of the grid-cell period ``model.P``**.</span>
<span class="sd">        resolution: positive integer</span>
<span class="sd">            Grid upsampling factor, defaults to 2</span>
<span class="sd">        nsamples: positive integer</span>
<span class="sd">            Number of samples to draw, defaults to 4000</span>
<span class="sd">        height_threshold: float in (0,1)</span>
<span class="sd">            Inclusion threshold for peak height in each </span>
<span class="sd">            sample and probability peak over all samples,</span>
<span class="sd">            default:0</span>
<span class="sd">        prpeak_threshold: float</span>
<span class="sd">            Probability threshold for including a peak,</span>
<span class="sd">            in [0,1], based on the fractions of samples</span>
<span class="sd">            that contain a given peak. Default is 0</span>
<span class="sd">        pct: float in (0,100)</span>
<span class="sd">            Percentile to use for confidence bounds,</span>
<span class="sd">            default is 95%.</span>
<span class="sd">        doplot: boolean</span>
<span class="sd">            Plot resulting grid map? Default is False.</span>
<span class="sd">        cmap: matplotlib.colormap</span>
<span class="sd">            Forwarded to ``imshow()`` if ``doplot=True``</span>
<span class="sd">        scalebar: boolean; default True</span>
<span class="sd">            Draw 1 meter scale bar?</span>
<span class="sd">        **kwargs:</span>
<span class="sd">            Forwarded to ``plot()`` if ``doplot`` is True</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SampledConfidence object with these attributes:</span>
<span class="sd">            samples: PosteriorSample</span>
<span class="sd">                A PosteriorSample object.</span>
<span class="sd">            ellipses: </span>
<span class="sd">                (x,y) coordinates for confidence ellipses,</span>
<span class="sd">                NaN delimeted.</span>
<span class="sd">            gaussians: </span>
<span class="sd">                List of (μ,Σ) 2D confidence Gaussians.</span>
<span class="sd">            arena: </span>
<span class="sd">                An Arena object representing the experiment</span>
<span class="sd">                arena at the upsampled resolution.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">L</span>

        <span class="c1"># Retrieve the posterior mode (in low-D frequency)</span>
        <span class="c1"># and variance (in space)</span>
        <span class="n">posterior_mean</span><span class="p">,</span><span class="n">posterior_variance</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        
        <span class="n">radius</span> <span class="o">*=</span> <span class="n">model</span><span class="o">.</span><span class="n">P</span>
        <span class="n">edge_radius</span> <span class="o">*=</span> <span class="n">model</span><span class="o">.</span><span class="n">P</span>
        
        <span class="c1"># Sample from the GP posterior (see posterior.py)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">PosteriorSample</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span>
            <span class="n">posterior_mean</span><span class="p">,</span>
            <span class="n">posterior_variance</span><span class="p">,</span>
            <span class="n">arena</span>            <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">arena</span><span class="p">,</span>
            <span class="n">nsamples</span>         <span class="o">=</span> <span class="n">nsamples</span><span class="p">,</span>
            <span class="n">resolution</span>       <span class="o">=</span> <span class="n">resolution</span><span class="p">,</span>
            <span class="n">radius</span>           <span class="o">=</span> <span class="n">radius</span><span class="p">,</span>
            <span class="n">edge_radius</span>      <span class="o">=</span> <span class="n">edge_radius</span><span class="p">,</span>
            <span class="n">height_threshold</span> <span class="o">=</span> <span class="n">height_threshold</span><span class="p">,</span>
            <span class="n">prpeak_threshold</span> <span class="o">=</span> <span class="n">prpeak_threshold</span><span class="p">)</span>
        
        <span class="c1"># peaks: 2 × NPEAKS (x,y) peak locations</span>
        <span class="c1"># prpeak: fractions of samples with peak here</span>
        <span class="c1"># pfield:</span>
        <span class="c1">#     normalized distribution of peak location for</span>
        <span class="c1">#     each Voronoi-segmented grid field</span>
        <span class="c1"># means: estimated centroid of each field</span>
        <span class="c1"># sigmas: 2x2 covariance ellipse of each field</span>
        <span class="n">peaks</span>  <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">peaks</span>
        <span class="n">prpeak</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">density</span>
        <span class="n">pfield</span> <span class="o">=</span> <span class="n">float32</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">pfield</span><span class="p">)</span>
        <span class="n">means</span>  <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">means</span>
        <span class="n">sigmas</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">sigmas</span>
        
        <span class="c1"># Convert scale</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">scale</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">resolution</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span><span class="o">/</span><span class="n">m1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="c1"># (cm/pixel)²</span>
        <span class="n">pfield</span> <span class="o">/=</span> <span class="n">dx</span>
        <span class="n">nfields</span> <span class="o">=</span> <span class="n">peaks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>    

        <span class="c1"># Collect all ellipses to plot </span>
        <span class="n">ellipses</span><span class="p">,</span><span class="n">gaussians</span> <span class="o">=</span> <span class="p">[],[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">mu</span><span class="p">,</span><span class="n">sigma</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">means</span><span class="p">,</span><span class="n">sigmas</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">isfinite</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">isfinite</span><span class="p">(</span><span class="n">mu</span><span class="p">)):</span>
                <span class="c1"># Prepare covariance ellipse for plotting</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">covariance_crosshairs</span><span class="p">(</span>
                    <span class="n">sigma</span><span class="p">,</span>
                    <span class="n">p</span><span class="o">=</span><span class="mf">.95</span><span class="p">,</span>
                    <span class="n">draw_cross</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">+</span> <span class="n">mu</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
                <span class="n">ellipses</span> <span class="o">+=</span><span class="p">[</span><span class="o">*</span><span class="n">z</span><span class="o">.</span><span class="n">T</span><span class="p">]</span><span class="o">+</span><span class="p">[(</span><span class="n">NaN</span><span class="p">,</span><span class="n">NaN</span><span class="p">)]</span>
                <span class="n">gaussians</span><span class="o">+=</span><span class="p">[(</span><span class="n">mu</span><span class="p">,</span><span class="n">sigma</span><span class="p">)]</span>
        <span class="n">ellipses</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">ellipses</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Get higher resolution masks for upsampled data</span>
        <span class="n">arena</span> <span class="o">=</span> <span class="n">Arena</span><span class="o">.</span><span class="n">from_mask</span><span class="p">(</span>
            <span class="n">data</span><span class="o">.</span><span class="n">arena</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span>
            <span class="n">resolution</span><span class="o">=</span><span class="n">resolution</span><span class="p">)</span>
        
        <span class="c1"># Create a plot of sampled confidence intervals</span>
        <span class="k">if</span> <span class="n">doplot</span><span class="p">:</span>
            <span class="c1"># Plot peak densities</span>
            <span class="n">vmax</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">percentile</span><span class="p">(</span>
                <span class="n">result</span><span class="o">.</span><span class="n">kde</span><span class="p">[</span><span class="n">arena</span><span class="o">.</span><span class="n">mask</span><span class="p">],</span><span class="mf">99.9</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span><span class="o">/</span><span class="mi">100</span>
            <span class="n">imshow</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">kde</span><span class="o">*</span><span class="n">arena</span><span class="o">.</span><span class="n">nanmask</span><span class="p">,</span>
                <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
                <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">draw_border</span><span class="p">:</span>
                <span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">arena</span><span class="o">.</span><span class="n">perimeter</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>

            <span class="n">truepct</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\%&#39;</span> <span class="k">if</span> \
                <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;text.usetex&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="s1">&#39;%&#39;</span>
            <span class="n">title</span><span class="p">(</span><span class="s1">&#39;Probable centers of each grid field&#39;</span>\
                  <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> Ellipses: 95&#39;</span>\
                  <span class="o">+</span><span class="n">truepct</span><span class="o">+</span><span class="s1">&#39; confidence&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">scalebar</span><span class="p">:</span>
                <span class="c1"># Add a scale bar</span>
                <span class="n">y0</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">arena</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="n">resolution</span><span class="p">)</span>
                <span class="n">y1</span> <span class="o">=</span> <span class="n">y0</span> <span class="o">-</span> <span class="n">m1</span><span class="o">/</span><span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="n">resolution</span><span class="p">)</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">arena</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">L</span><span class="o">/</span><span class="mi">20</span><span class="o">*</span><span class="n">resolution</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="n">resolution</span><span class="p">)</span>
                <span class="n">yscalebar</span><span class="p">((</span><span class="n">y0</span><span class="o">+</span><span class="n">y1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">y1</span><span class="o">-</span><span class="n">y0</span><span class="p">,</span><span class="s1">&#39;1 m&#39;</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span>
                          <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>

            <span class="c1"># Add color bar</span>
            <span class="n">good_colorbar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">vmax</span><span class="p">,</span>
                <span class="n">cmap</span><span class="p">,</span><span class="s1">&#39;$</span><span class="se">\\</span><span class="s1">Pr($peak$)$ / cm²&#39;</span><span class="p">,</span>
                <span class="n">fontsize</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span><span class="n">sideways</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">vscale</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
            <span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">ellipses</span><span class="p">,</span><span class="o">**</span><span class="p">{</span>
                <span class="s1">&#39;lw&#39;</span><span class="p">:</span><span class="mf">0.5</span><span class="p">,</span>
                <span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">OCHRE</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">})</span>
            <span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            <span class="n">ylim</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">arena</span>     <span class="o">=</span> <span class="n">arena</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span>   <span class="o">=</span> <span class="n">result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ellipses</span>  <span class="o">=</span> <span class="n">ellipses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gaussians</span> <span class="o">=</span> <span class="n">gaussians</span></div>


<div class="viewcode-block" id="QuadraticConfidence"><a class="viewcode-back" href="../../lgcpspatial.posterior.html#lgcpspatial.posterior.QuadraticConfidence">[docs]</a><span class="k">class</span> <span class="nc">QuadraticConfidence</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">model</span><span class="p">,</span>
        <span class="n">fit</span><span class="p">,</span>
        <span class="n">radius</span>              <span class="o">=</span> <span class="mf">0.45</span><span class="p">,</span>
        <span class="n">localization_radius</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
        <span class="n">edge_radius</span>         <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">height_threshold</span>    <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">pct</span>                 <span class="o">=</span> <span class="mi">95</span><span class="p">,</span>
        <span class="n">doplot</span>              <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">draw_border</span>         <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Locally-quadratic approximation of peak-location</span>
<span class="sd">        confidence intervals.</span>
<span class="sd">        </span>
<span class="sd">        **For small posterior variance:** The locally-</span>
<span class="sd">        quadratic intervals tend to be smaller than the</span>
<span class="sd">        peak-density map sampled intervals, because they</span>
<span class="sd">        exclude spurious peaks at intermediate locations.</span>
<span class="sd">        This has been spot-checked and found true using</span>
<span class="sd">        shuffle tests on the Krupic data, but should be</span>
<span class="sd">        verified again when using new data. </span>
<span class="sd">                </span>
<span class="sd">        **For large posterior variance:** The locally-</span>
<span class="sd">        quadratic intervals are not interpretable, since</span>
<span class="sd">        they do not account for the fact that grid fields</span>
<span class="sd">        are confined to a region related to the grid perid. </span>
<span class="sd">        Incorrect, large values will be returned. These</span>
<span class="sd">        should be discarded by setting the </span>
<span class="sd">        ``localization_radius`` parameter.       </span>
<span class="sd">    </span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        ellipses: list</span>
<span class="sd">            List of x,y coordinates for plotting confidence </span>
<span class="sd">            ellipses; NaN delimeted.</span>
<span class="sd">        gaussians: list </span>
<span class="sd">            List of (μ,Σ) 2D confidence Gaussians for </span>
<span class="sd">            all peaks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data: Dataset </span>
<span class="sd">        model: </span>
<span class="sd">            Model built from this data of type </span>
<span class="sd">            lgcp2d.diagonal_fourier_lowrank</span>
<span class="sd">        fit: </span>
<span class="sd">            Posterior fitted by lgcp2d.coordinate_descent</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        radius: float; Default 0.45</span>
<span class="sd">            Region in which a peak must be a local maximum </span>
<span class="sd">            to count as a grid field. </span>
<span class="sd">            This is in units of </span>
<span class="sd">            **fraction of the grid-cell period ``model.P``**.</span>
<span class="sd">        localization_radius: float; Default 0.8</span>
<span class="sd">            Drop peaks with confidence outside this radius.</span>
<span class="sd">            Set to ``inf`` to retain all peaks. </span>
<span class="sd">            This is in units of </span>
<span class="sd">            **fraction of the grid-cell period ``model.P``**.</span>
<span class="sd">        edge_radius: float; Default 0</span>
<span class="sd">            Remove peaks closer than ``edge_radius`` bins</span>
<span class="sd">            to the arena&#39;s edge. The default value of 0</span>
<span class="sd">            does not remove points within a margin of</span>
<span class="sd">            the boundary.</span>
<span class="sd">        height_threshold: float in (0,1); default 0.5</span>
<span class="sd">            Inclusion threshold for peak height in each </span>
<span class="sd">            sample and probability peak over all samples,</span>
<span class="sd">        prpeak_threshold: float</span>
<span class="sd">            Probability threshold for including a peak,</span>
<span class="sd">            iinterpolate_peaksn [0,1], based on the </span>
<span class="sd">            fractions of samples that contain a given peak.</span>
<span class="sd">        pct: float in (0,100); default 95.0</span>
<span class="sd">            percentile to use for confidence bounds,</span>
<span class="sd">        doplot: boolean, default True</span>
<span class="sd">            Render a plot of the grid map? Default:False. </span>
<span class="sd">        draw_border: boolean, default True</span>
<span class="sd">            Whether to render the arena border if plotting.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">use2d</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">h2e</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">cached</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">P</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span><span class="o">*</span><span class="n">P</span>
        <span class="n">localization_radius</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">localization_radius</span><span class="p">)</span><span class="o">*</span><span class="n">P</span>

        <span class="c1"># Retrieve the posterior mode (in low-D space) and </span>
        <span class="c1"># variance (in regular space)</span>
        <span class="c1"># Sample from the GP posterior (see posterior.py)</span>
        <span class="n">posterior_mean</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">μ</span> <span class="p">,</span><span class="n">λ</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">rates_from_lowrank</span><span class="p">(</span><span class="n">posterior_mean</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
        <span class="n">μ</span>    <span class="o">=</span> <span class="n">μ</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>

        <span class="c1"># Get peaks in arena</span>
        <span class="c1"># Note that these are peaks in the log-rate (μ)</span>
        <span class="c1"># not the rate, λ. </span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">interpolate_peaks</span><span class="p">(</span><span class="n">μ</span><span class="p">,</span>
            <span class="n">clearance_radius</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">radius</span><span class="p">)),</span>
            <span class="n">height_threshold</span> <span class="o">=</span>
            <span class="n">percentile</span><span class="p">(</span><span class="n">μ</span><span class="p">,</span><span class="mi">100</span><span class="o">*</span><span class="n">height_threshold</span><span class="p">))[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">peaks</span><span class="p">[:,</span><span class="n">is_in_hull</span><span class="p">(</span><span class="n">peaks</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">data</span><span class="o">.</span><span class="n">arena</span><span class="o">.</span><span class="n">hull</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">edge_radius</span><span class="o">&gt;</span><span class="mf">0.</span><span class="p">:</span>
            <span class="n">peaks</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">arena</span><span class="o">.</span><span class="n">remove_near_boundary</span><span class="p">(</span>
                <span class="n">peaks</span><span class="p">,</span> 
                <span class="n">edge_radius</span><span class="p">)</span>
        
        <span class="c1"># Get negative of 2×2 Hessians at all points</span>
        <span class="n">pidx</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">int32</span><span class="p">(</span><span class="n">peaks</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">L</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),)</span>
        <span class="n">H</span>    <span class="o">=</span> <span class="o">-</span><span class="n">hessian_2D</span><span class="p">(</span><span class="n">μ</span><span class="p">)[</span><span class="n">pidx</span><span class="p">]</span>

        <span class="c1"># Get post.r mean Hessian and covariance gradients</span>
        <span class="c1"># - Get low-rank Cholesky factor of covariance</span>
        <span class="c1"># - Construct discrete d/dx in low-D Hartley space</span>
        <span class="c1"># - Obtain low-rank derivatives (left-multiply)</span>
        <span class="c1"># - Project back to spatial domain only at peaks</span>
        <span class="c1">#   by keeping only those columns in the inverse  </span>
        <span class="c1">#   transform model.h2e that correspond to a peak </span>
        <span class="c1">#   location.</span>
        <span class="n">Q</span>   <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">low_rank_cholesky</span><span class="p">(</span><span class="n">posterior_mean</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">dx</span>  <span class="o">=</span> <span class="n">dx_op</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="n">fx</span>  <span class="o">=</span> <span class="n">fft2</span><span class="p">(</span><span class="n">dx</span>  <span class="p">,</span><span class="n">norm</span><span class="o">=</span><span class="s1">&#39;ortho&#39;</span><span class="p">)[</span><span class="n">use2d</span><span class="p">]</span>
        <span class="n">fy</span>  <span class="o">=</span> <span class="n">fft2</span><span class="p">(</span><span class="n">dx</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">norm</span><span class="o">=</span><span class="s1">&#39;ortho&#39;</span><span class="p">)[</span><span class="n">use2d</span><span class="p">]</span>
        <span class="n">fQ</span>  <span class="o">=</span> <span class="n">h2f_2d_truncated</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">use2d</span><span class="p">)</span>
        <span class="n">dxQ</span> <span class="o">=</span> <span class="n">RI</span><span class="p">((</span><span class="n">fx</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">fQ</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">dyQ</span> <span class="o">=</span> <span class="n">RI</span><span class="p">((</span><span class="n">fy</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">fQ</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># At this point, dxQ and dyQ are the x and y</span>
        <span class="c1"># derivatives applied on the left to the Cholesky</span>
        <span class="c1"># factor of the posterior covariance. Together, they</span>
        <span class="c1"># describe the derivatives of the posterior </span>
        <span class="c1"># covariance at all locations. In lgcp2d, h2e is </span>
        <span class="c1"># defined as the R×L² matrix of 2D fourier</span>
        <span class="c1"># components. Cutting out only the [pidx] locations</span>
        <span class="c1"># from this operator corresponds to inverting the</span>
        <span class="c1"># Hartley transform only at the locations where</span>
        <span class="c1"># peaks exist (saves time). </span>
        <span class="n">ispk</span> <span class="o">=</span> <span class="n">h2e</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">pidx</span><span class="p">]</span>
        <span class="n">J</span>    <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">ispk</span><span class="nd">@dxQ</span><span class="p">,</span><span class="n">ispk</span><span class="nd">@dyQ</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Calculate covariances, prepare crosshairs </span>
        <span class="c1"># - Get the expected peak shift covariance Σx0</span>
        <span class="c1"># - If peak is localized, plot confidence ellipse</span>
        <span class="c1"># - Collect all ellipse to plot at once (faster)</span>
        <span class="n">ellipses</span><span class="p">,</span><span class="n">gaussians</span><span class="p">,</span><span class="n">bad</span> <span class="o">=</span> <span class="p">[],[],[]</span>
        <span class="n">retained_peaks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">peaks</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">J</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ΣxJD</span> <span class="o">=</span> <span class="n">chsolve</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="n">Σx0</span>  <span class="o">=</span> <span class="n">ΣxJD</span><span class="nd">@ΣxJD</span><span class="o">.</span><span class="n">T</span>
            <span class="k">except</span> <span class="n">LinAlgError</span><span class="p">:</span>
                <span class="n">bad</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mx</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">cxy</span> <span class="o">=</span> <span class="n">covariance_crosshairs</span><span class="p">(</span>
                <span class="n">Σx0</span><span class="p">,</span>
                <span class="n">p</span><span class="o">=</span><span class="n">pct</span><span class="o">/</span><span class="mi">100</span><span class="p">,</span>
                <span class="n">draw_cross</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">cxy</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">&lt;</span><span class="n">localization_radius</span><span class="o">/</span><span class="n">L</span><span class="p">:</span>
                <span class="c1"># Peak is acceptably localized</span>
                <span class="n">ellipses</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cxy</span> <span class="o">+</span> <span class="n">mx</span><span class="p">)</span>
                <span class="n">ellipses</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">nan</span><span class="p">,)</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">gaussians</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mx</span><span class="p">,</span><span class="n">Σx0</span><span class="p">))</span>
                <span class="n">retained_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Peak is not acceptably localized</span>
                <span class="n">bad</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mx</span><span class="p">)</span>
        <span class="n">retained_peaks</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">retained_peaks</span><span class="p">)</span>
        <span class="n">ellipses</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">ellipses</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">doplot</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">draw_border</span><span class="p">:</span>
                <span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">arena</span><span class="o">.</span><span class="n">perimeter</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
                <span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">arena</span><span class="o">.</span><span class="n">perimeter</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;text.usetex&#39;</span><span class="p">]:</span>
                <span class="n">title</span><span class="p">(</span><span class="s1">&#39;Ellipses: </span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">pct</span><span class="p">)</span><span class="o">+</span>
                      <span class="sa">r</span><span class="s1">&#39;\</span><span class="si">% c</span><span class="s1">onfidence&#39;</span><span class="p">,</span><span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">title</span><span class="p">(</span><span class="s1">&#39;Ellipses: </span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">pct</span><span class="p">)</span><span class="o">+</span>
                      <span class="sa">r</span><span class="s1">&#39;</span><span class="si">% c</span><span class="s1">onfidence&#39;</span><span class="p">,</span><span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">ellipses</span><span class="p">,</span>
                 <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Quadratic&#39;</span><span class="p">,</span>
                 <span class="o">**</span><span class="p">{</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;lw&#39;</span><span class="p">:</span><span class="mf">.6</span><span class="p">,</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">MAUVE</span><span class="p">},</span><span class="o">**</span><span class="n">kwargs</span><span class="p">})</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad</span><span class="p">):</span>
                <span class="n">scatter</span><span class="p">(</span><span class="o">*</span><span class="n">array</span><span class="p">(</span><span class="n">bad</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">RUST</span><span class="p">,</span>
                        <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mf">.5</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
            <span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            <span class="n">axis</span><span class="p">(</span><span class="s1">&#39;square&#39;</span><span class="p">)</span>
            <span class="n">ylim</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">gaussians</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">UserWarning</span><span class="p">((</span>
                <span class="s1">&#39;No peaks were localized within &#39;</span>
                <span class="s1">&#39;localization_radius = </span><span class="si">%f</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="o">%</span><span class="n">localization_radius</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span>     <span class="o">=</span> <span class="n">retained_peaks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ellipses</span>  <span class="o">=</span> <span class="n">ellipses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gaussians</span> <span class="o">=</span> <span class="n">gaussians</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bad</span>       <span class="o">=</span> <span class="n">bad</span></div>


<div class="viewcode-block" id="QuadraticConfidenceJoint"><a class="viewcode-back" href="../../lgcpspatial.posterior.html#lgcpspatial.posterior.QuadraticConfidenceJoint">[docs]</a><span class="k">class</span> <span class="nc">QuadraticConfidenceJoint</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">model</span><span class="p">,</span>
        <span class="n">fit</span><span class="p">,</span> 
        <span class="n">radius</span>              <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">localization_radius</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_radius</span>         <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">height_threshold</span>    <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
        <span class="n">pct</span>                 <span class="o">=</span> <span class="mi">95</span><span class="p">,</span>
        <span class="n">regularization</span>      <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span>
        <span class="n">doplot</span>              <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Similar to QuadraticConfidence, but modified to </span>
<span class="sd">        return the joint covariance to address correlations </span>
<span class="sd">        between fields in the posterior introduced by the </span>
<span class="sd">        GP prior. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : </span>
<span class="sd">            Object containing the following fields:</span>
<span class="sd">                TODO</span>
<span class="sd">        model: </span>
<span class="sd">            model built from this data of type </span>
<span class="sd">            lgcp2d.diagonal_fourier_lowrank</span>
<span class="sd">        fit: </span>
<span class="sd">            fit posterior calculated by </span>
<span class="sd">            lgcp2d.coordinate_descent</span>
<span class="sd">        radius: float</span>
<span class="sd">            Region in which a peak must be a local maximum </span>
<span class="sd">            to count as a grid field. This is in units of </span>
<span class="sd">            &quot;bins&quot; on the L×L grid.</span>
<span class="sd">            **fraction of the grid-cell period ``model.P``**.</span>
<span class="sd">        localization_radius: float</span>
<span class="sd">            Drop peaks with confidence outside this radius.</span>
<span class="sd">            **fraction of the grid-cell period ``model.P``**.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        height_threshold: float in (0,1), default:.8</span>
<span class="sd">            Inclusion threshold for peak height in each </span>
<span class="sd">            sample  and probability peak over all samples, </span>
<span class="sd">            </span>
<span class="sd">        pct: float in (0,100), default:95</span>
<span class="sd">            percentile to use for confidence bounds</span>
<span class="sd">        edge_radius: float; Default 0</span>
<span class="sd">            Remove peaks closer than ``edge_radius`` bins</span>
<span class="sd">            to the arena&#39;s edge. The default value of 0</span>
<span class="sd">            does not remove points within a margin of</span>
<span class="sd">            the boundary.</span>
<span class="sd">        doplot: boolean, default:False. </span>
<span class="sd">            Plot resulting the grid map? </span>
<span class="sd">        **kwargs:</span>
<span class="sd">            Forwarded to plot()</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (rx,ry):</span>
<span class="sd">            Field locations</span>
<span class="sd">        ellipses: </span>
<span class="sd">            NaN-delimeted x,y coordinates for plotting </span>
<span class="sd">            confidence ellipses; </span>
<span class="sd">        gaussians: list</span>
<span class="sd">            (μ,Σ) 2D confidence Gaussians for all peaks.</span>
<span class="sd">        ok: list&lt;int&gt;</span>
<span class="sd">            Which of the ``(rx,ry)`` points were included </span>
<span class="sd">            in Σx0</span>
<span class="sd">        Σx0: </span>
<span class="sd">            Joint covariance of all included points, packed</span>
<span class="sd">            as ``(x,y)``</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">use2d</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">h2e</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">cached</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">P</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span><span class="o">*</span><span class="n">P</span>
        <span class="n">localization_radius</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">localization_radius</span><span class="p">)</span><span class="o">*</span><span class="n">P</span>

        <span class="c1"># Retrieve the posterior mode (in low-D space) and </span>
        <span class="c1"># variance (in regular space)</span>
        <span class="c1"># Sample from the GP posterior (see posterior.py)</span>
        <span class="n">posterior_mean</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">μ</span> <span class="p">,</span><span class="n">λ</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">rates_from_lowrank</span><span class="p">(</span><span class="n">posterior_mean</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
        <span class="n">μ</span>    <span class="o">=</span> <span class="n">μ</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>

        <span class="c1"># Get peaks in arena</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">interpolate_peaks</span><span class="p">(</span><span class="n">μ</span><span class="p">,</span>
            <span class="n">clearance_radius</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">radius</span><span class="p">)),</span>
            <span class="n">height_threshold</span> <span class="o">=</span> <span class="n">percentile</span><span class="p">(</span>
                <span class="n">μ</span><span class="p">,</span><span class="mi">100</span><span class="o">*</span><span class="n">height_threshold</span><span class="p">))[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">peaks</span><span class="p">[:,</span><span class="n">is_in_hull</span><span class="p">(</span><span class="n">peaks</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">data</span><span class="o">.</span><span class="n">arena</span><span class="o">.</span><span class="n">hull</span><span class="p">)]</span>

        <span class="c1"># Get negative of 2×2 Hessians at all points</span>
        <span class="n">pidx</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">int64</span><span class="p">(</span><span class="n">peaks</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">L</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),)</span>
        <span class="n">H</span>    <span class="o">=</span> <span class="o">-</span><span class="n">hessian_2D</span><span class="p">(</span><span class="n">μ</span><span class="p">)[</span><span class="n">pidx</span><span class="p">]</span>

        <span class="c1"># Obtain posterior derivatives</span>
        <span class="c1"># - Get low-rank Cholesky factor of covariance</span>
        <span class="c1"># - Get discrete derivatives in low-D Hartley space</span>
        <span class="c1"># - Get low-rank derivatives (left-multiply)</span>
        <span class="c1"># - Project back to spatial domain only at peaks</span>
        <span class="c1">#   by keeping only those columns in the inverse </span>
        <span class="c1">#   transform model.h2e that correspond to a peak </span>
        <span class="c1">#   location.</span>
        <span class="n">Q</span>   <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">low_rank_cholesky</span><span class="p">(</span><span class="n">posterior_mean</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">dx</span>  <span class="o">=</span> <span class="n">dx_op</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="n">fx</span>  <span class="o">=</span> <span class="n">fft2</span><span class="p">(</span><span class="n">dx</span>  <span class="p">,</span><span class="n">norm</span><span class="o">=</span><span class="s1">&#39;ortho&#39;</span><span class="p">)[</span><span class="n">use2d</span><span class="p">]</span>
        <span class="n">fy</span>  <span class="o">=</span> <span class="n">fft2</span><span class="p">(</span><span class="n">dx</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">norm</span><span class="o">=</span><span class="s1">&#39;ortho&#39;</span><span class="p">)[</span><span class="n">use2d</span><span class="p">]</span>
        <span class="n">fQ</span>  <span class="o">=</span> <span class="n">h2f_2d_truncated</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">use2d</span><span class="p">)</span>
        <span class="n">dxQ</span> <span class="o">=</span> <span class="n">RI</span><span class="p">((</span><span class="n">fx</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">fQ</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">dyQ</span> <span class="o">=</span> <span class="n">RI</span><span class="p">((</span><span class="n">fy</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">fQ</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># At this point, dxQ and dyQ are the x and y </span>
        <span class="c1"># derivatives applied on the left to the Cholesky </span>
        <span class="c1"># factor of the posterior covariance. Together, they</span>
        <span class="c1"># describe the derivatives of the posterior </span>
        <span class="c1"># covariance at all locations. In lgcp2d, h2e is </span>
        <span class="c1"># defined as the R×L² matrix of 2D fourier </span>
        <span class="c1"># components. Cutting out only the [pidx] locations </span>
        <span class="c1"># from this operator corresponds to inverting the </span>
        <span class="c1"># Hartley transform only at the locations where</span>
        <span class="c1"># peaks exist (saves time). </span>
        <span class="n">ispk</span> <span class="o">=</span> <span class="n">h2e</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">pidx</span><span class="p">]</span>
        <span class="n">J</span>    <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">ispk</span><span class="nd">@dxQ</span><span class="p">,</span><span class="n">ispk</span><span class="nd">@dyQ</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Calculate covariances and crosshairs </span>
        <span class="c1"># - Calculated expected peak shift covariance Σx0</span>
        <span class="c1"># - If peak is localized, plot 95% ellipse</span>
        <span class="c1"># - Collect all ellipse to plot at once (faster)</span>
        <span class="n">bad</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,(</span><span class="n">mx</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">peaks</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">J</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ΣxJD</span> <span class="o">=</span> <span class="n">chsolve</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="n">Σx0</span>  <span class="o">=</span> <span class="n">ΣxJD</span><span class="nd">@ΣxJD</span><span class="o">.</span><span class="n">T</span>
            <span class="k">except</span> <span class="n">LinAlgError</span><span class="p">:</span>
                <span class="n">bad</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="c1"># Use if peak is acceptably localized</span>
            <span class="n">cxy</span>  <span class="o">=</span> <span class="n">covariance_crosshairs</span><span class="p">(</span>
                <span class="n">Σx0</span><span class="p">,</span>
                <span class="n">p</span><span class="o">=</span><span class="n">pct</span><span class="o">/</span><span class="mi">100</span><span class="p">,</span>
                <span class="n">draw_cross</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">cxy</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">&gt;</span><span class="n">localization_radius</span><span class="o">/</span><span class="n">L</span><span class="p">:</span>
                <span class="n">bad</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>

        <span class="c1"># Reapeat on the good fields jointly</span>
        <span class="n">nfields</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">R</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">ok</span>    <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="o">*</span><span class="p">({</span><span class="o">*</span><span class="n">arange</span><span class="p">(</span><span class="n">nfields</span><span class="p">)}</span><span class="o">-</span><span class="p">{</span><span class="o">*</span><span class="n">bad</span><span class="p">})]))</span>
        <span class="n">nkeep</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ok</span><span class="p">)</span>
        <span class="n">JJ</span>    <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">nkeep</span><span class="p">,</span><span class="n">R</span><span class="p">)</span>
        <span class="n">HH</span>    <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">H</span><span class="p">[</span><span class="n">ok</span><span class="p">])</span>
        <span class="n">ΣxJD</span>  <span class="o">=</span> <span class="n">chsolve</span><span class="p">(</span><span class="n">float64</span><span class="p">(</span><span class="n">HH</span><span class="p">),</span><span class="n">float64</span><span class="p">(</span><span class="n">JJ</span><span class="p">))</span>
        <span class="n">Σx0</span>   <span class="o">=</span> <span class="n">ΣxJD</span><span class="nd">@ΣxJD</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Σx0</span>  <span class="o">+=</span> <span class="n">regularization</span><span class="o">*</span><span class="n">eye</span><span class="p">(</span><span class="n">Σx0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1"># Overwrite with updated confidence intervals</span>
        <span class="n">gaussians</span> <span class="o">=</span> <span class="p">[(</span><span class="n">peaks</span><span class="p">[:,</span><span class="n">iok</span><span class="p">],</span><span class="n">Σx0</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">:</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">:</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span> 
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">iok</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ok</span><span class="p">)]</span>
        
        <span class="n">ellipses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">mx</span><span class="p">,</span><span class="n">S</span> <span class="ow">in</span> <span class="n">gaussians</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">cxy</span>  <span class="o">=</span> <span class="n">covariance_crosshairs</span><span class="p">(</span>
                    <span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="n">pct</span><span class="o">/</span><span class="mi">100</span><span class="p">,</span><span class="n">draw_cross</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="n">ellipses</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cxy</span> <span class="o">+</span> <span class="n">mx</span><span class="p">)</span>
                <span class="n">ellipses</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">nan</span><span class="p">,)</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="n">ellipses</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">ellipses</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">doplot</span><span class="p">:</span>
            <span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">arena</span><span class="o">.</span><span class="n">perimeter</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
            <span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">arena</span><span class="o">.</span><span class="n">perimeter</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;text.usetex&#39;</span><span class="p">]:</span>
                <span class="n">title</span><span class="p">(</span><span class="s1">&#39;Ellipses: </span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">pct</span><span class="p">)</span><span class="o">+</span>\
                      <span class="sa">r</span><span class="s1">&#39;\</span><span class="si">% c</span><span class="s1">onfidence&#39;</span><span class="p">,</span><span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">title</span><span class="p">(</span><span class="s1">&#39;Ellipses: </span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">pct</span><span class="p">)</span><span class="o">+</span>\
                      <span class="sa">r</span><span class="s1">&#39;</span><span class="si">% c</span><span class="s1">onfidence&#39;</span><span class="p">,</span><span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">ellipses</span><span class="p">,</span>
                 <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Quadratic&#39;</span><span class="p">,</span>
                 <span class="o">**</span><span class="p">{</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;lw&#39;</span><span class="p">:</span><span class="mf">.6</span><span class="p">,</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">MAUVE</span><span class="p">},</span><span class="o">**</span><span class="n">kwargs</span><span class="p">})</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad</span><span class="p">):</span>
                <span class="n">scatter</span><span class="p">(</span>
                    <span class="o">*</span><span class="n">peaks</span><span class="p">[:,</span><span class="n">bad</span><span class="p">],</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">BLACK</span><span class="p">,</span>
                    <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span>
                    <span class="n">lw</span><span class="o">=</span><span class="mf">.5</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
            <span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            <span class="n">axis</span><span class="p">(</span><span class="s1">&#39;square&#39;</span><span class="p">)</span>
            <span class="n">ylim</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            figure(figsize=(10,10),dpi=120)</span>
<span class="sd">            imshow(Σx0,vmin=-.0001,vmax=.0001,</span>
<span class="sd">                extent=(0.5,nkeep+0.5)*2)</span>
<span class="sd">            xticks(arange(nkeep)+1,map(str,ok));</span>
<span class="sd">            yticks(arange(nkeep)+1,map(str,ok));</span>
<span class="sd">            for i in range(1,nkeep):</span>
<span class="sd">                axvline(i+0.5,color=&#39;w&#39;,lw=0.3)</span>
<span class="sd">                axhline(i+0.5,color=&#39;w&#39;,lw=0.3)</span>
<span class="sd">            &#39;&#39;&#39;</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">ellipses</span><span class="o">=</span><span class="n">ellipses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gaussians</span><span class="o">=</span><span class="n">gaussians</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ok</span><span class="o">=</span><span class="n">ok</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">joint_covariance</span><span class="o">=</span><span class="n">Σx0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="o">=</span><span class="n">peaks</span></div>


<div class="viewcode-block" id="QuadraticExponentialConfidence"><a class="viewcode-back" href="../../lgcpspatial.posterior.html#lgcpspatial.posterior.QuadraticExponentialConfidence">[docs]</a><span class="k">class</span> <span class="nc">QuadraticExponentialConfidence</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">model</span><span class="p">,</span>
        <span class="n">fit</span><span class="p">,</span>
        <span class="n">radius</span>              <span class="o">=</span> <span class="mf">0.45</span><span class="p">,</span>
        <span class="n">localization_radius</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
        <span class="n">edge_radius</span>         <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">height_threshold</span>    <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">pct</span>                 <span class="o">=</span> <span class="mi">95</span><span class="p">,</span>
        <span class="n">doplot</span>              <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">draw_border</span>         <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Locally-quadratic approximation based on the </span>
<span class="sd">        posterior firing-rate moments. </span>
<span class="sd">        </span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        ellipses: list</span>
<span class="sd">            List of x,y coordinates for plotting confidence </span>
<span class="sd">            ellipses; NaN delimeted.</span>
<span class="sd">        gaussians: list </span>
<span class="sd">            List of (μ,Σ) 2D confidence Gaussians for </span>
<span class="sd">            all peaks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data: Dataset </span>
<span class="sd">        model: </span>
<span class="sd">            Model built from this data of type </span>
<span class="sd">            lgcp2d.diagonal_fourier_lowrank</span>
<span class="sd">        fit: </span>
<span class="sd">            Posterior fitted by lgcp2d.coordinate_descent</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        radius: float; Default 0.45</span>
<span class="sd">            Region in which a peak must be a local maximum </span>
<span class="sd">            to count as a grid field. </span>
<span class="sd">            This is in units of </span>
<span class="sd">            **fraction of the grid-cell period ``model.P``**.</span>
<span class="sd">        localization_radius: float; Default 0.8</span>
<span class="sd">            Drop peaks with confidence outside this radius.</span>
<span class="sd">            Set to ``inf`` to retain all peaks. </span>
<span class="sd">            This is in units of </span>
<span class="sd">            **fraction of the grid-cell period ``model.P``**.</span>
<span class="sd">        edge_radius: float; Default 0</span>
<span class="sd">            Remove peaks closer than ``edge_radius`` bins</span>
<span class="sd">            to the arena&#39;s edge. The default value of 0</span>
<span class="sd">            does not remove points within a margin of</span>
<span class="sd">            the boundary.</span>
<span class="sd">        height_threshold: float in (0,1); default 0.5</span>
<span class="sd">            Inclusion threshold for peak height in each </span>
<span class="sd">            sample and probability peak over all samples,</span>
<span class="sd">        prpeak_threshold: float</span>
<span class="sd">            Probability threshold for including a peak,</span>
<span class="sd">            iinterpolate_peaksn [0,1], based on the </span>
<span class="sd">            fractions of samples that contain a given peak.</span>
<span class="sd">        pct: float in (0,100); default 95.0</span>
<span class="sd">            percentile to use for confidence bounds,</span>
<span class="sd">        doplot: boolean, default True</span>
<span class="sd">            Render a plot of the grid map? Default:False. </span>
<span class="sd">        draw_border: boolean, default True</span>
<span class="sd">            Whether to render the arena border if plotting.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">use2d</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">h2e</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">cached</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">P</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span><span class="o">*</span><span class="n">P</span>
        <span class="n">localization_radius</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">localization_radius</span><span class="p">)</span><span class="o">*</span><span class="n">P</span>

        <span class="c1"># Retrieve the posterior mode (in low-D space) and </span>
        <span class="c1"># variance (in regular space)</span>
        <span class="c1"># Sample from the GP posterior (see posterior.py)</span>
        <span class="n">posterior_mean</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">μ</span> <span class="p">,</span><span class="n">λ</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">rates_from_lowrank</span><span class="p">(</span><span class="n">posterior_mean</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
        <span class="n">μ</span>    <span class="o">=</span> <span class="n">μ</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>
        <span class="n">λ</span>    <span class="o">=</span> <span class="n">λ</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>
        
        <span class="c1"># Get peaks in arena</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">interpolate_peaks</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span>
            <span class="n">clearance_radius</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">radius</span><span class="p">)),</span>
            <span class="n">height_threshold</span> <span class="o">=</span>
            <span class="n">percentile</span><span class="p">(</span><span class="n">μ</span><span class="p">,</span><span class="mi">100</span><span class="o">*</span><span class="n">height_threshold</span><span class="p">))[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">peaks</span><span class="p">[:,</span><span class="n">is_in_hull</span><span class="p">(</span><span class="n">peaks</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">data</span><span class="o">.</span><span class="n">arena</span><span class="o">.</span><span class="n">hull</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">edge_radius</span><span class="o">&gt;</span><span class="mf">0.</span><span class="p">:</span>
            <span class="n">peaks</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">arena</span><span class="o">.</span><span class="n">remove_near_boundary</span><span class="p">(</span>
                <span class="n">peaks</span><span class="p">,</span> 
                <span class="n">edge_radius</span><span class="p">)</span>
        
        <span class="c1"># Get negative of 2×2 Hessians at all points</span>
        <span class="n">pidx</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">int32</span><span class="p">(</span><span class="n">peaks</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">L</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),)</span>
        <span class="n">H</span>    <span class="o">=</span> <span class="o">-</span><span class="n">hessian_2D</span><span class="p">(</span><span class="n">λ</span><span class="p">)[</span><span class="n">pidx</span><span class="p">]</span>
        

        <span class="c1"># Get post.r mean Hessian and covariance gradients</span>
        <span class="c1"># - Get low-rank Cholesky factor of covariance</span>
        <span class="c1"># - Construct discrete d/dx in low-D Hartley space</span>
        <span class="c1"># - Obtain low-rank derivatives (left-multiply)</span>
        <span class="c1"># - Project back to spatial domain only at peaks</span>
        <span class="c1">#   by keeping only those columns in the inverse  </span>
        <span class="c1">#   transform model.h2e that correspond to a peak </span>
        <span class="c1">#   location.</span>
        <span class="n">Q</span>   <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">low_rank_cholesky</span><span class="p">(</span><span class="n">posterior_mean</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">dx</span>  <span class="o">=</span> <span class="n">dx_op</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="n">fx</span>  <span class="o">=</span> <span class="n">fft2</span><span class="p">(</span><span class="n">dx</span>  <span class="p">,</span><span class="n">norm</span><span class="o">=</span><span class="s1">&#39;ortho&#39;</span><span class="p">)[</span><span class="n">use2d</span><span class="p">]</span>
        <span class="n">fy</span>  <span class="o">=</span> <span class="n">fft2</span><span class="p">(</span><span class="n">dx</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">norm</span><span class="o">=</span><span class="s1">&#39;ortho&#39;</span><span class="p">)[</span><span class="n">use2d</span><span class="p">]</span>
        <span class="n">fQ</span>  <span class="o">=</span> <span class="n">h2f_2d_truncated</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">use2d</span><span class="p">)</span>
        <span class="n">dxQ</span> <span class="o">=</span> <span class="n">RI</span><span class="p">((</span><span class="n">fx</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">fQ</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">dyQ</span> <span class="o">=</span> <span class="n">RI</span><span class="p">((</span><span class="n">fy</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">fQ</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># At this point, dxQ and dyQ are the x and y</span>
        <span class="c1"># derivatives applied on the left to the Cholesky</span>
        <span class="c1"># factor of the posterior covariance. Together, they</span>
        <span class="c1"># describe the derivatives of the posterior </span>
        <span class="c1"># covariance at all locations. In lgcp2d, h2e is </span>
        <span class="c1"># defined as the R×L² matrix of 2D fourier</span>
        <span class="c1"># components. Cutting out only the [pidx] locations</span>
        <span class="c1"># from this operator corresponds to inverting the</span>
        <span class="c1"># Hartley transform only at the locations where</span>
        <span class="c1"># peaks exist (saves time). </span>
        <span class="n">ispk</span> <span class="o">=</span> <span class="n">h2e</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">pidx</span><span class="p">]</span>
        <span class="n">J</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="n">ispk</span><span class="nd">@dxQ</span><span class="p">,</span><span class="n">ispk</span><span class="nd">@dyQ</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># We will need the posterior second moment of λ</span>
        <span class="c1"># This is λ²exp(v)</span>
        <span class="n">M2</span> <span class="o">=</span> <span class="p">(</span><span class="n">λ</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">L</span><span class="p">)))[</span><span class="n">pidx</span><span class="p">]</span>
        
        <span class="c1"># Calculate covariances, prepare crosshairs </span>
        <span class="c1"># - Get the expected peak shift covariance Σx0</span>
        <span class="c1"># - If peak is localized, plot confidence ellipse</span>
        <span class="c1"># - Collect all ellipse to plot at once (faster)</span>
        <span class="n">ellipses</span><span class="p">,</span><span class="n">gaussians</span><span class="p">,</span><span class="n">bad</span><span class="p">,</span><span class="n">good</span> <span class="o">=</span> <span class="p">[],[],[],[]</span>
        <span class="n">retained_peaks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">peaks</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">M2</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ΣxJD</span> <span class="o">=</span> <span class="n">chsolve</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="n">Σx0</span>  <span class="o">=</span> <span class="p">(</span><span class="n">ΣxJD</span><span class="nd">@ΣxJD</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">m2</span>
            <span class="k">except</span> <span class="n">LinAlgError</span><span class="p">:</span>
                <span class="n">bad</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mx</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">cxy</span> <span class="o">=</span> <span class="n">covariance_crosshairs</span><span class="p">(</span>
                <span class="n">Σx0</span><span class="p">,</span>
                <span class="n">p</span><span class="o">=</span><span class="n">pct</span><span class="o">/</span><span class="mi">100</span><span class="p">,</span>
                <span class="n">draw_cross</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">cxy</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">&lt;</span><span class="n">localization_radius</span><span class="o">/</span><span class="n">L</span><span class="p">:</span>
                <span class="c1"># Peak is acceptably localized</span>
                <span class="n">ellipses</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cxy</span> <span class="o">+</span> <span class="n">mx</span><span class="p">)</span>
                <span class="n">ellipses</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">nan</span><span class="p">,)</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">good</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mx</span><span class="p">)</span>
                <span class="n">gaussians</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mx</span><span class="p">,</span><span class="n">Σx0</span><span class="p">))</span>
                <span class="n">retained_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Peak is not acceptably localized</span>
                <span class="n">bad</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mx</span><span class="p">)</span>
        <span class="n">retained_peaks</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">retained_peaks</span><span class="p">)</span>
        <span class="n">ellipses</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">ellipses</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">doplot</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">draw_border</span><span class="p">:</span>
                <span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">arena</span><span class="o">.</span><span class="n">perimeter</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
                <span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">arena</span><span class="o">.</span><span class="n">perimeter</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;text.usetex&#39;</span><span class="p">]:</span>
                <span class="n">title</span><span class="p">(</span><span class="s1">&#39;Ellipses: </span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">pct</span><span class="p">)</span><span class="o">+</span>
                      <span class="sa">r</span><span class="s1">&#39;\</span><span class="si">% c</span><span class="s1">onfidence&#39;</span><span class="p">,</span><span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">title</span><span class="p">(</span><span class="s1">&#39;Ellipses: </span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">pct</span><span class="p">)</span><span class="o">+</span>
                      <span class="sa">r</span><span class="s1">&#39;</span><span class="si">% c</span><span class="s1">onfidence&#39;</span><span class="p">,</span><span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">ellipses</span><span class="p">,</span>
                 <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Quadratic&#39;</span><span class="p">,</span>
                 <span class="o">**</span><span class="p">{</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;lw&#39;</span><span class="p">:</span><span class="mf">.6</span><span class="p">,</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">MAUVE</span><span class="p">},</span><span class="o">**</span><span class="n">kwargs</span><span class="p">})</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad</span><span class="p">):</span>
                <span class="n">scatter</span><span class="p">(</span><span class="o">*</span><span class="n">array</span><span class="p">(</span><span class="n">bad</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">RUST</span><span class="p">,</span>
                        <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mf">.5</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
            <span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            <span class="n">axis</span><span class="p">(</span><span class="s1">&#39;square&#39;</span><span class="p">)</span>
            <span class="n">ylim</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">gaussians</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">UserWarning</span><span class="p">((</span>
                <span class="s1">&#39;No peaks were localized within &#39;</span>
                <span class="s1">&#39;localization_radius = </span><span class="si">%f</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="o">%</span><span class="n">localization_radius</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span>     <span class="o">=</span> <span class="n">retained_peaks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ellipses</span>  <span class="o">=</span> <span class="n">ellipses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gaussians</span> <span class="o">=</span> <span class="n">gaussians</span></div>

        
<div class="viewcode-block" id="fraction_within_arena"><a class="viewcode-back" href="../../lgcpspatial.posterior.html#lgcpspatial.posterior.fraction_within_arena">[docs]</a><span class="k">def</span> <span class="nf">fraction_within_arena</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">gaussians</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This function is depricated. Testing whether </span>
<span class="sd">    peaks are close to the edge is now handled by</span>
<span class="sd">    ``load_data.Arena.remove_near_boundary()``</span>
<span class="sd">    </span>
<span class="sd">    For a list of 2D Gaussians given as (μ,Σ) tuples, </span>
<span class="sd">    estimate the fraction of probability mass within </span>
<span class="sd">    data.arena.hull. </span>
<span class="sd">    </span>
<span class="sd">    This uses fairly crude numerical integration; It is</span>
<span class="sd">    sufficiently accurate for testing whether fields</span>
<span class="sd">    lie too close to the edge of the arena.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    --------------------------------------------------------</span>
<span class="sd">    data: Dataset</span>
<span class="sd">    gaussians list</span>
<span class="sd">        List of (μ,Σ) 2D Gaussians</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    --------------------------------------------------------</span>
<span class="sd">    np.float32:</span>
<span class="sd">        Fraction of each Gaussian within the dataset&#39;s</span>
<span class="sd">        arena&#39;s convex hull. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#zg = zgrid(N*2+1)/N</span>
    <span class="c1">#zg = c2p(zg[abs(zg)&lt;=1])</span>
    <span class="n">zg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">200</span><span class="p">)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">μ</span><span class="p">,</span><span class="n">Σ</span> <span class="ow">in</span> <span class="n">gaussians</span><span class="p">:</span>
        <span class="n">e</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">Σ</span><span class="p">)</span>
        <span class="n">zt</span>  <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">zg</span><span class="o">*</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">])</span><span class="o">+</span><span class="n">μ</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean</span><span class="p">(</span><span class="n">is_in_hull</span><span class="p">(</span><span class="n">zt</span><span class="p">,</span><span class="n">data</span><span class="o">.</span><span class="n">arena</span><span class="o">.</span><span class="n">hull</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">float32</span><span class="p">(</span><span class="n">results</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2022, M. E. Rule; P. Chaudhuri-Vayalambrone.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>